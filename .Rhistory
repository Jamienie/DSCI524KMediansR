m <- matrix(
c(1,1,2,2),
nrow = 2,
ncol = 2,
byrow = TRUE)
test_that("missing input errors", {
expect_error(distance(X = NULL, medians = m),
'non-numeric matrix extent')
expect_error(distance(X = A, medians = NULL),
'non-numeric matrix extent')
})
test_that("datatype errors", {
expect_error(distance(X = "abcd", medians = m),
'non-numeric matrix extent')
expect_error(distance(X = 100, medians = m),
'non-numeric matrix extent')
expect_error(distance(X = c(1,2), medians = m),
'non-numeric matrix extent')
expect_error(distance(X = list(c(1,2)), medians = m),
'non-numeric matrix extent')
expect_error(distance(X = A, medians = "abcd"),
'non-numeric matrix extent')
expect_error(distance(X = A, medians = 100),
'non-numeric matrix extent')
expect_error(distance(X = A, medians = c(1,2)),
'non-numeric matrix extent')
expect_error(distance(X = A, medians = list(c(1,2)),
'non-numeric matrix extent'))
})
test_that("test if output is matrix given toy data", {
expect_equal(is.matrix(distance(X = A, medians = m)), TRUE)
})
test_that("test size of output given toy data", {
expect_equal(nrow(distance(X = A, medians = m)), nrow(A))
expect_equal(ncol(distance(X = A, medians = m)), nrow(m))
})
test_that("test if the distance given toy data are right", {
expect_equal(distance(X = A, medians = m)[,1], c(1,5,9))
expect_equal(distance(X = A, medians = m)[,2], c(1,3,7))
})
kmedians <- function(X, num_clusters, n_it=100){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# n_it: integer
# The number of loops. Default value is 100.
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
d <- distance(X, medians)
labels <- apply(d, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
n <- 2
kmedians(A,2)
library(devtools)
library("UBC-MDS/KMediansR")
install_github('UBC-MDS/KMediansR')
library(KMediansR)
install_github('UBC-MDS/KMediansR')
library(KMediansR)
library(KMediansR)
context("testing kmedians clustering")
# toy data for calculation
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
n <- 2
test_that("missing input errors", {
expect_error(kmedians(X = NULL, num_clusters = n),
'missing X')
expect_error(kmedians(X = A, num_clusters = NULL),
'missing num_clusters')
})
kmedians <- function(X, num_clusters, n_it=100){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# n_it: integer
# The number of loops. Default value is 100.
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
d <- distance(X, medians)
labels <- apply(d, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
kmedians(X = NULL, num_clusters = n)
library(KMediansR)
library(KMediansR)
context("testing kmedians clustering")
# toy data for calculation
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
n <- 2
test_that("missing input errors", {
expect_error(kmedians(X = NULL, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = NULL),
'non-numeric matrix extent')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = 100, num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = A, num_clusters = 1.5),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = "2"),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = 0),
'num_clusters should not be 0')
})
test_that("error if num_clusters is larger than the data rows", {
expect_error(kmedians(X = A, num_clusters = nrow(A)+1),
'num_clusters must be less than or equal to data points')
})
test_that("test if output is a list given toy data", {
expect_equal(is.list(kmedians(X = A, num_clusters = n)), TRUE)
})
test_that("test size of output given toy data", {
expect_equal(length(kmedians(X = A, num_clusters = n)), 2)
expect_equal(nrow(kmedians(X = A, num_clusters = n)[[1]]), n)
# number of medians equals to number of clusters
expect_equal(lengths(kmedians(X = A, num_clusters = n)[2]), nrow(A))
# number of labels equals to number of data points
})
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(match(kmedians(X = A, num_clusters = n)[[1]],1), 2)
expect_equal(match(kmedians(X = A, num_clusters = n)[[1]],100), 2)
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],0), 3)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],1), 3)
})
remove.packages("KMediansR", lib="~/R/win-library/3.5")
library(devtools)
install_github('UBC-MDS/KMediansR')
library(KMediansR)
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
kmedians(A,2
)
kmedians(A,2)
kmedians <- function(X, num_clusters, n_it=100){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# n_it: integer
# The number of loops. Default value is 100.
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
K <- nrow(medians)
N <- nrow(X)
dist <- matrix(nrow=N,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
labels <- apply(dist, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
kmedians(A,2)
kmedians <- function(X, num_clusters, n_it=100){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# n_it: integer
# The number of loops. Default value is 100.
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
K <- nrow(medians)
N <- nrow(X)
dist <- matrix(nrow=N,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
labels <- apply(dist, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
# toy data for calculation
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
n <- 2
test_that("missing input errors", {
expect_error(kmedians(X = NULL, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = NULL),
'non-numeric matrix extent')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = 100, num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'X should be matrix')
expect_error(kmedians(X = A, num_clusters = 1.5),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = "2"),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = 0),
'num_clusters should not be 0')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = 100, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 1.5),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = "2"),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = 0),
'num_clusters should not be 0')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = 100, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 1.5),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = "2"),
'num_clusters should be integer')
expect_error(kmedians(X = A, num_clusters = 0),
'subscript out of bounds')
})
test_that("missing input errors", {
expect_error(kmedians(X = NULL, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = NULL),
'non-numeric matrix extent')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = 100, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 1.5),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = "2"),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 0),
'subscript out of bounds')
})
test_that("error if num_clusters is larger than the data rows", {
expect_error(kmedians(X = A, num_clusters = nrow(A)+1),
'num_clusters must be less than or equal to data points')
})
test_that("error if num_clusters is larger than the data rows", {
expect_error(kmedians(X = A, num_clusters = nrow(A)+1),
'cannot take a sample larger than the population when 'replace = FALSE'')
})
test_that("error if num_clusters is larger than the data rows", {
expect_error(kmedians(X = A, num_clusters = nrow(A)+1),
"cannot take a sample larger than the population when 'replace = FALSE'")
})
test_that("test if output is a list given toy data", {
expect_equal(is.list(kmedians(X = A, num_clusters = n)), TRUE)
})
test_that("test size of output given toy data", {
expect_equal(length(kmedians(X = A, num_clusters = n)), 2)
expect_equal(nrow(kmedians(X = A, num_clusters = n)[[1]]), n)
# number of medians equals to number of clusters
expect_equal(lengths(kmedians(X = A, num_clusters = n)[2]), nrow(A))
# number of labels equals to number of data points
})
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(match(kmedians(X = A, num_clusters = n)[[1]],1), 2)
expect_equal(match(kmedians(X = A, num_clusters = n)[[1]],100), 2)
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],0), 3)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],1), 3)
})
kmedians(A,2)
kmedians(X = A, num_clusters = n)[[1]]
match(kmedians(X = A, num_clusters = n)[[1]],1
match(kmedians(X = A, num_clusters = n)[[1]],1)
match(kmedians(X = A, num_clusters = n)[[1]],1)
match(kmedians(X = A, num_clusters = n)[[1]],1)==1
sum(match(kmedians(X = A, num_clusters = n)[[1]],1))
kmedians(X = A, num_clusters = n)[[1]]
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(1,1))
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(1,1))
expect_equal(match(kmedians(X = A, num_clusters = n)[[1]],100), 2)
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],0), 3)
expect_equal(match(kmedians(X = A, num_clusters = n)[[2]],1), 3)
})
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(1,1))
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(100,100))
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(kmedians(X = A, num_clusters = n)[[2]], c(0,0,0,1,1,1))
})
kmedians(X = A, num_clusters = n)[[1]]
kmedians(X = A, num_clusters = n)[[1]][1,]
kmedians(X = A, num_clusters = n)[[1]][1,] == c(1,1)
kmedians(X = A, num_clusters = n)[[2]]
# toy data for calculation
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
n <- 2
test_that("missing input errors", {
expect_error(kmedians(X = NULL, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = NULL),
'non-numeric matrix extent')
})
test_that("datatype errors", {
expect_error(kmedians(X = "abcd", num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = 100, num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = c(1,2), num_clusters = n),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 1.5),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = "2"),
'non-numeric matrix extent')
expect_error(kmedians(X = A, num_clusters = 0),
'subscript out of bounds')
})
test_that("error if num_clusters is larger than the data rows", {
expect_error(kmedians(X = A, num_clusters = nrow(A)+1),
"cannot take a sample larger than the population when 'replace = FALSE'")
})
test_that("test if output is a list given toy data", {
expect_equal(is.list(kmedians(X = A, num_clusters = n)), TRUE)
})
test_that("test size of output given toy data", {
expect_equal(length(kmedians(X = A, num_clusters = n)), 2)
expect_equal(nrow(kmedians(X = A, num_clusters = n)[[1]]), n)
# number of medians equals to number of clusters
expect_equal(lengths(kmedians(X = A, num_clusters = n)[2]), nrow(A))
# number of labels equals to number of data points
})
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(1,1))
expect_equal(kmedians(X = A, num_clusters = n)[[1]][2,], c(100,100))
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(kmedians(X = A, num_clusters = n)[[2]], c(1,1,1,2,2,22))
})
kmedians(X = A, num_clusters = n)[[2]]
test_that("test if the medians and clustering given toy data are correct", {
expect_equal(kmedians(X = A, num_clusters = n)[[1]][1,], c(1,1))
expect_equal(kmedians(X = A, num_clusters = n)[[1]][2,], c(100,100))
expect_equal(length(unique(kmedians(X = A, num_clusters = n)[[2]])), 2)
expect_equal(kmedians(X = A, num_clusters = n)[[2]], c(1,1,1,2,2,2))
})
library(devtools)
install_github('UBC-MDS/KMediansR')
library(KMediansR)
A <- matrix(
c(1,1,1,2,2,1,100,100,101,100,100,101),
nrow = 6,
ncol = 2,
byrow = TRUE)
kmedians(A,2)
